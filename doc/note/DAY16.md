# 更新Redis中数据的策略

通常，更新Redis中的数据，可以采用的策略有：

- 缓存预热：当服务器启动时，就更新Redis中的数据
  - 几乎适用于所有需要缓存的数据，只不过某些数据可能还需要辅助使用其它的更新策略，但并不绝对，例如处理单点登录时需要写入的用户状态就不适用于这种策略
- 即时更新：当MySQL中的数据发生变化时，就更新Redis中的数据
  - 对数据的实时一致性要求较高的应用场景
- 定时更新：当MySQL中的数据发生变化时，并不更新Redis中的数据，而是每过一段时间，或到了特定的时间点，再统一更新Redis中的数据
  - 对数据的实时一致性要求不是特别高的应用场景
- 被动更新：当查询Redis时，如果Redis中的数据并不存在，则尝试从MySQL中查询，并将查询到的结果写入到Redis中，这类数据通常会设置有效期
- 手动更新：具有特定权限的用户显式的执行更新操作
  - 适用于需要长时间存储在Redis中，且更新频率完全没有规律的数据

以上策略都可能需要组合使用，也就是说，每种数据可能不只使用1种更新策略。

# 计划任务

计划任务：可以指定执行时间，当满足时间条件时才会执行的任务，通常，表现为每过一段时间，或到了特定的时间点，才会执行，在实际应用中，计划任务可能是比较耗时的，所以，计划任务本身上是开启了新的子线程去执行的任务。

在Spring Boot项目中，默认并未开启计划任务，需要在配置类上添加`@EnableScheduling`注解，才能启用当项目项目中的计划任务。

在Spring Boot项目中，可以自定义组件类，在类中自定义方法（`public` / `void` / 无参数），并在方法上添加`@Scheduled`注解，在此注解中配置参数，以指定计划任务的执行规律。

关于`@Scheduled`注解的属性配置：

- `fixedRate`：执行频率（以上一次执行的起始时间来计算下一次的执行时间），取值为`long`数值，以毫秒为单位
  - 首次执行发生在项目启动完成的前一刻
  - 多次执行时的毫秒值时间略有偏差，多次时毫秒值来回波动
- `fixedDelay`：执行间隔（以上一次执行的结束时间来计算下一次的执行时间），取值为`long`数值，以毫秒为单位
  - 首次执行发生在项目启动完成的前一刻
  - 多次执行时的毫秒值时间略有偏差，多次时毫秒值一直递增

- `cron`：使用CRON表达式来配置执行时间，此表达式本质上是一个字符串，此字符串由6~7个值（域）组成，各个值（域）之间使用空格分隔，这些值（域）分别表示：`秒 分 时 日 月 星期 [年]`，关于各个域的取值：
  - 秒：取值范围为`0~59`，可使用的通配符：`*`，还可以结合使用特殊字符：`, - /`
  - 分：取值范围为`0~59`，可使用的通配符：`*`，还可以结合使用特殊字符：`, - /`
  - 时：取值范围为`0~23`，可使用的通配符：`*`，还可以结合使用特殊字符：`, - /`
  - 日：取值范围为`1~31`，可使用的通配符：`* ?` ，还可以结合使用特殊字符：`, - / L W`
  - 月：取值范围为`1~12`，或`JAN~DEC`，可使用的通配符：`*`，还可以结合使用特殊字符：`, - /`
  - 星期：取值范围为`1~7`（注意：1=星期天，以此类推），或`SUN~SAT`，可使用的通配符：`* ?`，还可以结合使用特殊字符：`, - / L #`
  - 年：取值范围为`1970~2099`，可使用的通配符：`*`，还可以结合使用特殊字符：`, - /`
  - **注意：**不要同时指定“日”和“星期”，通常，当指定了其中这2个域当中的某1个域的值后，另一个域会使用`?`，问号表示“不关心此值”（匹配时不检查）
  - **注意：**在使用的特殊字符中，`/`的左右两侧都必须有数字，分别表示执行的起始值和间隔周期，例如，在“分钟”的域位置使用`0/5`，则表示“分钟”值为`0`时将执行，且每间隔5分钟执行一次
  - **注意：**在“日期”上，当指定值后还可以结合`W`表示接下来最近的工作日，例如`18W`表示“18号后的首个工作日”
  - **注意：**在“星期”上，当指定值后还可以结合`#`指定第几次，例如`MON#3`表示“第3个星期一”

关于CRON表达式的练习：

```
（0）0/20 * * * * ? 表示每20秒 调整任务

（1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务

（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业

（3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作

（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点

（5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时

（6）0 0 12 ? * WED 表示每个星期三中午12点

（7）0 0 12 * * ? 每天中午12点触发

（8）0 15 10 ? * * 每天上午10:15触发

（9）0 15 10 * * ? 每天上午10:15触发

（10）0 15 10 * * ? * 每天上午10:15触发

（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发

（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发

（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发

（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发

（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发

（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发

（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发

（18）0 15 10 15 * ? 每月15日上午10:15触发

（19）0 15 10 L * ? 每月最后一日的上午10:15触发

（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发

（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发

（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发

（24）“30 * * * * ?” 每半分钟触发任务

（25）“30 10 * * * ?” 每小时的10分30秒触发任务

（23）“30 10 1 * * ?” 每天1点10分30秒触发任务

（26）“30 10 1 20 * ?” 每月20号1点10分30秒触发任务

（27）“30 10 1 20 10 ? *” 每年10月20号1点10分30秒触发任务

（28）“30 10 1 20 10 ? 2011” 2011年10月20号1点10分30秒触发任务

（29）“30 10 1 ? 10 * 2011” 2011年10月每天1点10分30秒触发任务

（30）“30 10 1 ? 10 SUN 2011” 2011年10月每周日1点10分30秒触发任务
————————————————
版权声明：本文为CSDN博主「一枚双鱼座的程序员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/study_665/article/details/123506946
```



# 请参考`tmall-server-repo`开发必要功能

开发功能：

- 【tmall-admin-mall】根据ID查询商品详情
  - Mapper层需要使用关联查询，查询出`goods_detail`表中的`detail`
- 【tmall-admin-mall】查询商品列表
  - Mapper层需要显式的指定`ORDER BY`子句
- 【tmall-admin-mall】根据类别查询商品列表
  - Mapper层需要显式的指定`ORDER BY`子句
- 【tmall-client-admin】参考`/src/views/admin/mall/GoodsManagementView`、`src/http/TokenAxios`
  - 注意检查各请求的路径是否正确
- 【tmall-front-mall】创建商城前台管理模块项目
  - 在根项目下创建`tmall-front`，并在`tmall-front`下创建`tmall-front-mall`，此模块项目是前台（普通用户使用的）处理商城相关请求的
  - **注意：**处理单点登录时，应该将“商品”、“类别”等不需要通过认证的请求都配置到“白名单”中
- 【tmall-front-mall】查询商品的相关功能
  - 根据ID查询商品详情
  - 查询推荐的商品列表
  - 根据类别查询商品列表
  - **注意：**以上查询都必须添加`check_state=1`条件，并且，查询的字段列表必须不包含`check_state`

- 【tmall-basic】缓存省市区数据的code与名称的对应关系

  - 在`IDistricCacheRepository`中添加抽象方法：

    ```java
    void save(DistrictSimplePO districtSimplePO);
    ```

  - 在`DistrictCacheRepository`中实现以上方法

    - 向Redis中存入省市区数据的同时，还需要将当前使用的Key保存到专门记录Key的Set中

  - 在`DistrictServiceImpl`中，重建缓存时，一边写入列表数据，一边写入每个省市区数据









